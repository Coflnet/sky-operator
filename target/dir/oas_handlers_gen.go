// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"time"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"

	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
)

// handleApplyPostRequest handles POST /Apply operation.
//
// Brings all products, groups and roles into the given state
// will disable/delete anything not present so use carefully.
//
// POST /Apply
func (s *Server) handleApplyPostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ApplyPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ApplyPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeApplyPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ApplyPostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ApplyPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *SystemState
			Params   = struct{}
			Response = *ApplyPostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ApplyPost(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.ApplyPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeApplyPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCallbackPaypalPostRequest handles POST /Callback/paypal operation.
//
// Accept callbacks from paypal.
//
// POST /Callback/paypal
func (s *Server) handleCallbackPaypalPostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CallbackPaypalPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response *CallbackPaypalPostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CallbackPaypalPost",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *CallbackPaypalPostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.CallbackPaypalPost(ctx)
				return response, err
			},
		)
	} else {
		err = s.h.CallbackPaypalPost(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCallbackPaypalPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleCallbackStripePostRequest handles POST /Callback/stripe operation.
//
// Webhook callback for stripe.
//
// POST /Callback/stripe
func (s *Server) handleCallbackStripePostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CallbackStripePost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response *CallbackStripePostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "CallbackStripePost",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *CallbackStripePostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.CallbackStripePost(ctx)
				return response, err
			},
		)
	} else {
		err = s.h.CallbackStripePost(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCallbackStripePostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGroupGetRequest handles GET /Group operation.
//
// GET /Group
func (s *Server) handleGroupGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GroupGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GroupGet",
			ID:   "",
		}
	)
	params, err := decodeGroupGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Group
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GroupGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
				{
					Name: "amount",
					In:   "query",
				}: params.Amount,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GroupGetParams
			Response = []Group
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGroupGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GroupGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GroupGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGroupGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGroupGroupSlugDeleteRequest handles DELETE /Group/{groupSlug} operation.
//
// DELETE /Group/{groupSlug}
func (s *Server) handleGroupGroupSlugDeleteRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GroupGroupSlugDelete",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GroupGroupSlugDelete",
			ID:   "",
		}
	)
	params, err := decodeGroupGroupSlugDeleteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Group
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GroupGroupSlugDelete",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "groupSlug",
					In:   "path",
				}: params.GroupSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GroupGroupSlugDeleteParams
			Response = *Group
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGroupGroupSlugDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GroupGroupSlugDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GroupGroupSlugDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGroupGroupSlugDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGroupGroupSlugGetRequest handles GET /Group/{groupSlug} operation.
//
// GET /Group/{groupSlug}
func (s *Server) handleGroupGroupSlugGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GroupGroupSlugGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GroupGroupSlugGet",
			ID:   "",
		}
	)
	params, err := decodeGroupGroupSlugGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Group
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GroupGroupSlugGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "groupSlug",
					In:   "path",
				}: params.GroupSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GroupGroupSlugGetParams
			Response = *Group
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGroupGroupSlugGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GroupGroupSlugGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GroupGroupSlugGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGroupGroupSlugGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGroupGroupSlugProductsDeleteRequest handles DELETE /Group/{groupSlug}/products operation.
//
// DELETE /Group/{groupSlug}/products
func (s *Server) handleGroupGroupSlugProductsDeleteRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GroupGroupSlugProductsDelete",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GroupGroupSlugProductsDelete",
			ID:   "",
		}
	)
	params, err := decodeGroupGroupSlugProductsDeleteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGroupGroupSlugProductsDeleteRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Group
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GroupGroupSlugProductsDelete",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "groupSlug",
					In:   "path",
				}: params.GroupSlug,
			},
			Raw: r,
		}

		type (
			Request  = []string
			Params   = GroupGroupSlugProductsDeleteParams
			Response = *Group
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGroupGroupSlugProductsDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GroupGroupSlugProductsDelete(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GroupGroupSlugProductsDelete(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGroupGroupSlugProductsDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGroupGroupSlugProductsPostRequest handles POST /Group/{groupSlug}/products operation.
//
// POST /Group/{groupSlug}/products
func (s *Server) handleGroupGroupSlugProductsPostRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GroupGroupSlugProductsPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GroupGroupSlugProductsPost",
			ID:   "",
		}
	)
	params, err := decodeGroupGroupSlugProductsPostParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGroupGroupSlugProductsPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Group
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GroupGroupSlugProductsPost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "groupSlug",
					In:   "path",
				}: params.GroupSlug,
			},
			Raw: r,
		}

		type (
			Request  = []string
			Params   = GroupGroupSlugProductsPostParams
			Response = *Group
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGroupGroupSlugProductsPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GroupGroupSlugProductsPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GroupGroupSlugProductsPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGroupGroupSlugProductsPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGroupGroupSlugPutRequest handles PUT /Group/{groupSlug} operation.
//
// PUT /Group/{groupSlug}
func (s *Server) handleGroupGroupSlugPutRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GroupGroupSlugPut",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GroupGroupSlugPut",
			ID:   "",
		}
	)
	params, err := decodeGroupGroupSlugPutParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeGroupGroupSlugPutRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Group
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GroupGroupSlugPut",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "groupSlug",
					In:   "path",
				}: params.GroupSlug,
			},
			Raw: r,
		}

		type (
			Request  = *Group
			Params   = GroupGroupSlugPutParams
			Response = *Group
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGroupGroupSlugPutParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GroupGroupSlugPut(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GroupGroupSlugPut(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGroupGroupSlugPutResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleGroupPostRequest handles POST /Group operation.
//
// POST /Group
func (s *Server) handleGroupPostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GroupPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GroupPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeGroupPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Group
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "GroupPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *Group
			Params   = struct{}
			Response = *Group
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GroupPost(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.GroupPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGroupPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProductsGetRequest handles GET /Products operation.
//
// Get all products.
//
// GET /Products
func (s *Server) handleProductsGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProductsGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProductsGet",
			ID:   "",
		}
	)
	params, err := decodeProductsGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []PurchaseableProduct
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProductsGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
				{
					Name: "amount",
					In:   "query",
				}: params.Amount,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProductsGetParams
			Response = []PurchaseableProduct
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProductsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProductsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProductsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProductsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProductsPProductSlugGetRequest handles GET /Products/p/{productSlug} operation.
//
// Get the details of a product.
//
// GET /Products/p/{productSlug}
func (s *Server) handleProductsPProductSlugGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProductsPProductSlugGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProductsPProductSlugGet",
			ID:   "",
		}
	)
	params, err := decodeProductsPProductSlugGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PurchaseableProduct
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProductsPProductSlugGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "productSlug",
					In:   "path",
				}: params.ProductSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProductsPProductSlugGetParams
			Response = *PurchaseableProduct
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProductsPProductSlugGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProductsPProductSlugGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProductsPProductSlugGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProductsPProductSlugGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProductsPutRequest handles PUT /Products operation.
//
// Updates a product by replacing it with a new one.
// Old products can not be deleted to furfill accounting needs.
//
// PUT /Products
func (s *Server) handleProductsPutRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProductsPut",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProductsPut",
			ID:   "",
		}
	)
	request, close, err := s.decodeProductsPutRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *PurchaseableProduct
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProductsPut",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *PurchaseableProduct
			Params   = struct{}
			Response = *PurchaseableProduct
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProductsPut(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProductsPut(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProductsPutResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProductsServiceServiceSlugCountGetRequest handles GET /Products/service/{serviceSlug}/count operation.
//
// Count of users owning a service.
//
// GET /Products/service/{serviceSlug}/count
func (s *Server) handleProductsServiceServiceSlugCountGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProductsServiceServiceSlugCountGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProductsServiceServiceSlugCountGet",
			ID:   "",
		}
	)
	params, err := decodeProductsServiceServiceSlugCountGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response int32
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProductsServiceServiceSlugCountGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "serviceSlug",
					In:   "path",
				}: params.ServiceSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProductsServiceServiceSlugCountGetParams
			Response = int32
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProductsServiceServiceSlugCountGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProductsServiceServiceSlugCountGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProductsServiceServiceSlugCountGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProductsServiceServiceSlugCountGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProductsServiceServiceSlugIdsGetRequest handles GET /Products/service/{serviceSlug}/ids operation.
//
// Gets all userIds owning a service.
//
// GET /Products/service/{serviceSlug}/ids
func (s *Server) handleProductsServiceServiceSlugIdsGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProductsServiceServiceSlugIdsGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProductsServiceServiceSlugIdsGet",
			ID:   "",
		}
	)
	params, err := decodeProductsServiceServiceSlugIdsGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []string
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProductsServiceServiceSlugIdsGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "serviceSlug",
					In:   "path",
				}: params.ServiceSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProductsServiceServiceSlugIdsGetParams
			Response = []string
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProductsServiceServiceSlugIdsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProductsServiceServiceSlugIdsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProductsServiceServiceSlugIdsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProductsServiceServiceSlugIdsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProductsServicesGetRequest handles GET /Products/services operation.
//
// Get services.
//
// GET /Products/services
func (s *Server) handleProductsServicesGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProductsServicesGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProductsServicesGet",
			ID:   "",
		}
	)
	params, err := decodeProductsServicesGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []PurchaseableProduct
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProductsServicesGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
				{
					Name: "amount",
					In:   "query",
				}: params.Amount,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProductsServicesGetParams
			Response = []PurchaseableProduct
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProductsServicesGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProductsServicesGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProductsServicesGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProductsServicesGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProductsTopupGetRequest handles GET /Products/topup operation.
//
// Get topup options.
//
// GET /Products/topup
func (s *Server) handleProductsTopupGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProductsTopupGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProductsTopupGet",
			ID:   "",
		}
	)
	params, err := decodeProductsTopupGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []TopUpProduct
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProductsTopupGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
				{
					Name: "amount",
					In:   "query",
				}: params.Amount,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProductsTopupGetParams
			Response = []TopUpProduct
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProductsTopupGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProductsTopupGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProductsTopupGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProductsTopupGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProductsTopupPutRequest handles PUT /Products/topup operation.
//
// Updates a topup option by replacing it with a new one.
// Old options get a new slug and are marked as disabled.
//
// PUT /Products/topup
func (s *Server) handleProductsTopupPutRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProductsTopupPut",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProductsTopupPut",
			ID:   "",
		}
	)
	request, close, err := s.decodeProductsTopupPutRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TopUpProduct
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProductsTopupPut",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *TopUpProduct
			Params   = struct{}
			Response = *TopUpProduct
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProductsTopupPut(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProductsTopupPut(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProductsTopupPutResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleProductsUserUserIdGetRequest handles GET /Products/user/{userId} operation.
//
// Get adjusted prices for a user.
//
// GET /Products/user/{userId}
func (s *Server) handleProductsUserUserIdGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProductsUserUserIdGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "ProductsUserUserIdGet",
			ID:   "",
		}
	)
	params, err := decodeProductsUserUserIdGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []RuleResult
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "ProductsUserUserIdGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
				{
					Name: "productSlugs",
					In:   "query",
				}: params.ProductSlugs,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProductsUserUserIdGetParams
			Response = []RuleResult
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProductsUserUserIdGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProductsUserUserIdGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProductsUserUserIdGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProductsUserUserIdGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleRulesGetRequest handles GET /Rules operation.
//
// Returns all rules.
//
// GET /Rules
func (s *Server) handleRulesGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "RulesGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RulesGet",
			ID:   "",
		}
	)
	params, err := decodeRulesGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []Rule
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "RulesGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
				{
					Name: "amount",
					In:   "query",
				}: params.Amount,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = RulesGetParams
			Response = []Rule
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRulesGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RulesGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RulesGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRulesGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleRulesPostRequest handles POST /Rules operation.
//
// Creates a new rule.
//
// POST /Rules
func (s *Server) handleRulesPostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "RulesPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RulesPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeRulesPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Rule
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "RulesPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *RuleCreate
			Params   = struct{}
			Response = *Rule
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RulesPost(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.RulesPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRulesPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleRulesRuleSlugDeleteRequest handles DELETE /Rules/{ruleSlug} operation.
//
// Deletes a rule.
//
// DELETE /Rules/{ruleSlug}
func (s *Server) handleRulesRuleSlugDeleteRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "RulesRuleSlugDelete",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RulesRuleSlugDelete",
			ID:   "",
		}
	)
	params, err := decodeRulesRuleSlugDeleteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Rule
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "RulesRuleSlugDelete",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "ruleSlug",
					In:   "path",
				}: params.RuleSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = RulesRuleSlugDeleteParams
			Response = *Rule
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRulesRuleSlugDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RulesRuleSlugDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RulesRuleSlugDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRulesRuleSlugDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleRulesRuleSlugGetRequest handles GET /Rules/{ruleSlug} operation.
//
// Returns a rule by slug.
//
// GET /Rules/{ruleSlug}
func (s *Server) handleRulesRuleSlugGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "RulesRuleSlugGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "RulesRuleSlugGet",
			ID:   "",
		}
	)
	params, err := decodeRulesRuleSlugGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Rule
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "RulesRuleSlugGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "ruleSlug",
					In:   "path",
				}: params.RuleSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = RulesRuleSlugGetParams
			Response = *Rule
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRulesRuleSlugGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RulesRuleSlugGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RulesRuleSlugGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRulesRuleSlugGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTopUpCompensatePostRequest handles POST /TopUp/compensate operation.
//
// Compensates users of a service for something.
//
// POST /TopUp/compensate
func (s *Server) handleTopUpCompensatePostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TopUpCompensatePost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TopUpCompensatePost",
			ID:   "",
		}
	)
	request, close, err := s.decodeTopUpCompensatePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Int32Int32ValueTuple
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TopUpCompensatePost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *Compensation
			Params   = struct{}
			Response = *Int32Int32ValueTuple
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TopUpCompensatePost(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.TopUpCompensatePost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTopUpCompensatePostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTopUpCustomPostRequest handles POST /TopUp/custom operation.
//
// Creates a custom topup that is instantly credited.
//
// POST /TopUp/custom
func (s *Server) handleTopUpCustomPostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TopUpCustomPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TopUpCustomPost",
			ID:   "",
		}
	)
	params, err := decodeTopUpCustomPostParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTopUpCustomPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TopUpIdResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TopUpCustomPost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "query",
				}: params.UserId,
			},
			Raw: r,
		}

		type (
			Request  = *CustomTopUp
			Params   = TopUpCustomPostParams
			Response = *TopUpIdResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTopUpCustomPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TopUpCustomPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TopUpCustomPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTopUpCustomPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTopUpOptionsGetRequest handles GET /TopUp/options operation.
//
// All available topup options.
//
// GET /TopUp/options
func (s *Server) handleTopUpOptionsGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TopUpOptionsGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err error
	)

	var response []TopUpProduct
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TopUpOptionsGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = []TopUpProduct
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TopUpOptionsGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.TopUpOptionsGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTopUpOptionsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTopUpPaypalPostRequest handles POST /TopUp/paypal operation.
//
// Creates a payment session with paypal.
//
// POST /TopUp/paypal
func (s *Server) handleTopUpPaypalPostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TopUpPaypalPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TopUpPaypalPost",
			ID:   "",
		}
	)
	params, err := decodeTopUpPaypalPostParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTopUpPaypalPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TopUpIdResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TopUpPaypalPost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "query",
				}: params.UserId,
				{
					Name: "productId",
					In:   "query",
				}: params.ProductId,
			},
			Raw: r,
		}

		type (
			Request  = *TopUpOptions
			Params   = TopUpPaypalPostParams
			Response = *TopUpIdResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTopUpPaypalPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TopUpPaypalPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TopUpPaypalPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTopUpPaypalPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTopUpStripePostRequest handles POST /TopUp/stripe operation.
//
// Creates a payment session with stripe.
//
// POST /TopUp/stripe
func (s *Server) handleTopUpStripePostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TopUpStripePost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TopUpStripePost",
			ID:   "",
		}
	)
	params, err := decodeTopUpStripePostParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTopUpStripePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TopUpIdResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TopUpStripePost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "query",
				}: params.UserId,
				{
					Name: "productId",
					In:   "query",
				}: params.ProductId,
			},
			Raw: r,
		}

		type (
			Request  = *TopUpOptions
			Params   = TopUpStripePostParams
			Response = *TopUpIdResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTopUpStripePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TopUpStripePost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TopUpStripePost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTopUpStripePostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTransactionPlanedUUserIdGetRequest handles GET /Transaction/planed/u/{userId} operation.
//
// GET /Transaction/planed/u/{userId}
func (s *Server) handleTransactionPlanedUUserIdGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TransactionPlanedUUserIdGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TransactionPlanedUUserIdGet",
			ID:   "",
		}
	)
	params, err := decodeTransactionPlanedUUserIdGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []ExternalTransaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TransactionPlanedUUserIdGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TransactionPlanedUUserIdGetParams
			Response = []ExternalTransaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTransactionPlanedUUserIdGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TransactionPlanedUUserIdGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TransactionPlanedUUserIdGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTransactionPlanedUUserIdGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTransactionPlanedUUserIdPostRequest handles POST /Transaction/planed/u/{userId} operation.
//
// POST /Transaction/planed/u/{userId}
func (s *Server) handleTransactionPlanedUUserIdPostRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TransactionPlanedUUserIdPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TransactionPlanedUUserIdPost",
			ID:   "",
		}
	)
	params, err := decodeTransactionPlanedUUserIdPostParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTransactionPlanedUUserIdPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *PlanedTransaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TransactionPlanedUUserIdPost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
			},
			Raw: r,
		}

		type (
			Request  = *ExternalTransaction
			Params   = TransactionPlanedUUserIdPostParams
			Response = *PlanedTransaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTransactionPlanedUUserIdPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TransactionPlanedUUserIdPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TransactionPlanedUUserIdPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTransactionPlanedUUserIdPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTransactionPlanedUUserIdTTransactionIdDeleteRequest handles DELETE /Transaction/planed/u/{userId}/t/{transactionId} operation.
//
// DELETE /Transaction/planed/u/{userId}/t/{transactionId}
func (s *Server) handleTransactionPlanedUUserIdTTransactionIdDeleteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TransactionPlanedUUserIdTTransactionIdDelete",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TransactionPlanedUUserIdTTransactionIdDelete",
			ID:   "",
		}
	)
	params, err := decodeTransactionPlanedUUserIdTTransactionIdDeleteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PlanedTransaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TransactionPlanedUUserIdTTransactionIdDelete",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
				{
					Name: "transactionId",
					In:   "path",
				}: params.TransactionId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TransactionPlanedUUserIdTTransactionIdDeleteParams
			Response = *PlanedTransaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTransactionPlanedUUserIdTTransactionIdDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TransactionPlanedUUserIdTTransactionIdDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TransactionPlanedUUserIdTTransactionIdDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTransactionPlanedUUserIdTTransactionIdDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTransactionPlanedUUserIdTTransactionIdPutRequest handles PUT /Transaction/planed/u/{userId}/t/{transactionId} operation.
//
// PUT /Transaction/planed/u/{userId}/t/{transactionId}
func (s *Server) handleTransactionPlanedUUserIdTTransactionIdPutRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TransactionPlanedUUserIdTTransactionIdPut",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TransactionPlanedUUserIdTTransactionIdPut",
			ID:   "",
		}
	)
	params, err := decodeTransactionPlanedUUserIdTTransactionIdPutParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeTransactionPlanedUUserIdTTransactionIdPutRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *PlanedTransaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TransactionPlanedUUserIdTTransactionIdPut",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
				{
					Name: "transactionId",
					In:   "path",
				}: params.TransactionId,
			},
			Raw: r,
		}

		type (
			Request  = *ExternalTransaction
			Params   = TransactionPlanedUUserIdTTransactionIdPutParams
			Response = *PlanedTransaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTransactionPlanedUUserIdTTransactionIdPutParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TransactionPlanedUUserIdTTransactionIdPut(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TransactionPlanedUUserIdTTransactionIdPut(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTransactionPlanedUUserIdTTransactionIdPutResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTransactionSendPostRequest handles POST /Transaction/send operation.
//
// POST /Transaction/send
func (s *Server) handleTransactionSendPostRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TransactionSendPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TransactionSendPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeTransactionSendPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TransactionSendPostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TransactionSendPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *TransactionEvent
			Params   = struct{}
			Response = *TransactionSendPostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TransactionSendPost(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.TransactionSendPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTransactionSendPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleTransactionUUserIdGetRequest handles GET /Transaction/u/{userId} operation.
//
// GET /Transaction/u/{userId}
func (s *Server) handleTransactionUUserIdGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TransactionUUserIdGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "TransactionUUserIdGet",
			ID:   "",
		}
	)
	params, err := decodeTransactionUUserIdGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []ExternalTransaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "TransactionUUserIdGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TransactionUUserIdGetParams
			Response = []ExternalTransaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTransactionUUserIdGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TransactionUUserIdGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TransactionUUserIdGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTransactionUUserIdGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUserUserIdGetRequest handles GET /User/{userId} operation.
//
// Gets the user with the given id.
//
// GET /User/{userId}
func (s *Server) handleUserUserIdGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UserUserIdGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UserUserIdGet",
			ID:   "",
		}
	)
	params, err := decodeUserUserIdGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *User
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UserUserIdGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UserUserIdGetParams
			Response = *User
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUserUserIdGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserUserIdGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserUserIdGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserUserIdGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUserUserIdOwnsLongestPostRequest handles POST /User/{userId}/owns/longest operation.
//
// Returns the bigest time out of a list of product ids.
//
// POST /User/{userId}/owns/longest
func (s *Server) handleUserUserIdOwnsLongestPostRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UserUserIdOwnsLongestPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UserUserIdOwnsLongestPost",
			ID:   "",
		}
	)
	params, err := decodeUserUserIdOwnsLongestPostParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUserUserIdOwnsLongestPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response time.Time
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UserUserIdOwnsLongestPost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
			},
			Raw: r,
		}

		type (
			Request  = []string
			Params   = UserUserIdOwnsLongestPostParams
			Response = time.Time
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUserUserIdOwnsLongestPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserUserIdOwnsLongestPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserUserIdOwnsLongestPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserUserIdOwnsLongestPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUserUserIdOwnsPostRequest handles POST /User/{userId}/owns operation.
//
// Returns all ownership data for an user out of a list of interested.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /User/{userId}/owns
func (s *Server) handleUserUserIdOwnsPostRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UserUserIdOwnsPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UserUserIdOwnsPost",
			ID:   "",
		}
	)
	params, err := decodeUserUserIdOwnsPostParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUserUserIdOwnsPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response []OwnerShip
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UserUserIdOwnsPost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
			},
			Raw: r,
		}

		type (
			Request  = []string
			Params   = UserUserIdOwnsPostParams
			Response = []OwnerShip
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUserUserIdOwnsPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserUserIdOwnsPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserUserIdOwnsPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserUserIdOwnsPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUserUserIdOwnsProductSlugUntilGetRequest handles GET /User/{userId}/owns/{productSlug}/until operation.
//
// Returns the time for how long a user owns a given product.
//
// GET /User/{userId}/owns/{productSlug}/until
func (s *Server) handleUserUserIdOwnsProductSlugUntilGetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UserUserIdOwnsProductSlugUntilGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UserUserIdOwnsProductSlugUntilGet",
			ID:   "",
		}
	)
	params, err := decodeUserUserIdOwnsProductSlugUntilGetParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response time.Time
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UserUserIdOwnsProductSlugUntilGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
				{
					Name: "productSlug",
					In:   "path",
				}: params.ProductSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UserUserIdOwnsProductSlugUntilGetParams
			Response = time.Time
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUserUserIdOwnsProductSlugUntilGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserUserIdOwnsProductSlugUntilGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserUserIdOwnsProductSlugUntilGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserUserIdOwnsProductSlugUntilGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUserUserIdOwnsUntilPostRequest handles POST /User/{userId}/owns/until operation.
//
// Returns all ownership data for an user out of a list of interested.
//
// POST /User/{userId}/owns/until
func (s *Server) handleUserUserIdOwnsUntilPostRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UserUserIdOwnsUntilPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UserUserIdOwnsUntilPost",
			ID:   "",
		}
	)
	params, err := decodeUserUserIdOwnsUntilPostParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUserUserIdOwnsUntilPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UserUserIdOwnsUntilPostOKApplicationJSON
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UserUserIdOwnsUntilPost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
			},
			Raw: r,
		}

		type (
			Request  = []string
			Params   = UserUserIdOwnsUntilPostParams
			Response = UserUserIdOwnsUntilPostOKApplicationJSON
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUserUserIdOwnsUntilPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserUserIdOwnsUntilPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserUserIdOwnsUntilPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserUserIdOwnsUntilPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUserUserIdPostRequest handles POST /User/{userId} operation.
//
// Creates a new user with the given id.
//
// POST /User/{userId}
func (s *Server) handleUserUserIdPostRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UserUserIdPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UserUserIdPost",
			ID:   "",
		}
	)
	params, err := decodeUserUserIdPostParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *User
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UserUserIdPost",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UserUserIdPostParams
			Response = *User
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUserUserIdPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserUserIdPost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserUserIdPost(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserUserIdPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUserUserIdPurchaseProductSlugPostRequest handles POST /User/{userId}/purchase/{productSlug} operation.
//
// Purchase a new product if enough funds are available.
//
// POST /User/{userId}/purchase/{productSlug}
func (s *Server) handleUserUserIdPurchaseProductSlugPostRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UserUserIdPurchaseProductSlugPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UserUserIdPurchaseProductSlugPost",
			ID:   "",
		}
	)
	params, err := decodeUserUserIdPurchaseProductSlugPostParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *User
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UserUserIdPurchaseProductSlugPost",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
				{
					Name: "productSlug",
					In:   "path",
				}: params.ProductSlug,
				{
					Name: "price",
					In:   "query",
				}: params.Price,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UserUserIdPurchaseProductSlugPostParams
			Response = *User
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUserUserIdPurchaseProductSlugPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserUserIdPurchaseProductSlugPost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserUserIdPurchaseProductSlugPost(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserUserIdPurchaseProductSlugPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUserUserIdServicePurchaseProductSlugPostRequest handles POST /User/{userId}/service/purchase/{productSlug} operation.
//
// Purchase/extends a service if enough funds are available.
//
// POST /User/{userId}/service/purchase/{productSlug}
func (s *Server) handleUserUserIdServicePurchaseProductSlugPostRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UserUserIdServicePurchaseProductSlugPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UserUserIdServicePurchaseProductSlugPost",
			ID:   "",
		}
	)
	params, err := decodeUserUserIdServicePurchaseProductSlugPostParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *User
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UserUserIdServicePurchaseProductSlugPost",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
				{
					Name: "productSlug",
					In:   "path",
				}: params.ProductSlug,
				{
					Name: "reference",
					In:   "query",
				}: params.Reference,
				{
					Name: "count",
					In:   "query",
				}: params.Count,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UserUserIdServicePurchaseProductSlugPostParams
			Response = *User
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUserUserIdServicePurchaseProductSlugPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserUserIdServicePurchaseProductSlugPost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserUserIdServicePurchaseProductSlugPost(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserUserIdServicePurchaseProductSlugPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUserUserIdTransactionIdDeleteRequest handles DELETE /User/{userId}/{transactionId} operation.
//
// Undo the purchase of a service.
//
// DELETE /User/{userId}/{transactionId}
func (s *Server) handleUserUserIdTransactionIdDeleteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UserUserIdTransactionIdDelete",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UserUserIdTransactionIdDelete",
			ID:   "",
		}
	)
	params, err := decodeUserUserIdTransactionIdDeleteParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *User
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UserUserIdTransactionIdDelete",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
				{
					Name: "transactionId",
					In:   "path",
				}: params.TransactionId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UserUserIdTransactionIdDeleteParams
			Response = *User
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUserUserIdTransactionIdDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserUserIdTransactionIdDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserUserIdTransactionIdDelete(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserUserIdTransactionIdDeleteResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleUserUserIdTransferPostRequest handles POST /User/{userId}/transfer operation.
//
// Transfers coins to another user.
//
// POST /User/{userId}/transfer
func (s *Server) handleUserUserIdTransferPostRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UserUserIdTransferPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, otelAttrs...)

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, otelAttrs...)
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "UserUserIdTransferPost",
			ID:   "",
		}
	)
	params, err := decodeUserUserIdTransferPostParams(args, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUserUserIdTransferPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TransactionEvent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "UserUserIdTransferPost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "userId",
					In:   "path",
				}: params.UserId,
			},
			Raw: r,
		}

		type (
			Request  = *TransferRequest
			Params   = UserUserIdTransferPostParams
			Response = *TransactionEvent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUserUserIdTransferPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserUserIdTransferPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserUserIdTransferPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserUserIdTransferPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}
