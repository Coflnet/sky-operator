// Code generated by ogen, DO NOT EDIT.

package api

import (
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
)

// Encode implements json.Marshaler.
func (s *Compensation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Compensation) encodeFields(e *jx.Encoder) {
	{
		if s.ProductId.Set {
			e.FieldStart("productId")
			s.ProductId.Encode(e)
		}
	}
	{
		if s.Reference.Set {
			e.FieldStart("reference")
			s.Reference.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.When.Set {
			e.FieldStart("when")
			s.When.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCompensation = [4]string{
	0: "productId",
	1: "reference",
	2: "amount",
	3: "when",
}

// Decode decodes Compensation from json.
func (s *Compensation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Compensation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "productId":
			if err := func() error {
				s.ProductId.Reset()
				if err := s.ProductId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productId\"")
			}
		case "reference":
			if err := func() error {
				s.Reference.Reset()
				if err := s.Reference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reference\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "when":
			if err := func() error {
				s.When.Reset()
				if err := s.When.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"when\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Compensation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Compensation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Compensation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CustomTopUp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CustomTopUp) encodeFields(e *jx.Encoder) {
	{
		if s.ProductId.Set {
			e.FieldStart("productId")
			s.ProductId.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.Reference.Set {
			e.FieldStart("reference")
			s.Reference.Encode(e)
		}
	}
}

var jsonFieldsNameOfCustomTopUp = [3]string{
	0: "productId",
	1: "amount",
	2: "reference",
}

// Decode decodes CustomTopUp from json.
func (s *CustomTopUp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomTopUp to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "productId":
			if err := func() error {
				s.ProductId.Reset()
				if err := s.ProductId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productId\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "reference":
			if err := func() error {
				s.Reference.Reset()
				if err := s.Reference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reference\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CustomTopUp")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CustomTopUp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomTopUp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalTransaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalTransaction) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ProductId.Set {
			e.FieldStart("productId")
			s.ProductId.Encode(e)
		}
	}
	{
		if s.Reference.Set {
			e.FieldStart("reference")
			s.Reference.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.TimeStamp.Set {
			e.FieldStart("timeStamp")
			s.TimeStamp.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfExternalTransaction = [5]string{
	0: "id",
	1: "productId",
	2: "reference",
	3: "amount",
	4: "timeStamp",
}

// Decode decodes ExternalTransaction from json.
func (s *ExternalTransaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalTransaction to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "productId":
			if err := func() error {
				s.ProductId.Reset()
				if err := s.ProductId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productId\"")
			}
		case "reference":
			if err := func() error {
				s.Reference.Reset()
				if err := s.Reference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reference\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "timeStamp":
			if err := func() error {
				s.TimeStamp.Reset()
				if err := s.TimeStamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeStamp\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalTransaction")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalTransaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalTransaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Group) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Group) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		if s.Products.Set {
			e.FieldStart("products")
			s.Products.Encode(e)
		}
	}
}

var jsonFieldsNameOfGroup = [3]string{
	0: "id",
	1: "slug",
	2: "products",
}

// Decode decodes Group from json.
func (s *Group) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Group to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "products":
			if err := func() error {
				s.Products.Reset()
				if err := s.Products.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"products\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Group")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Group) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Group) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Int32Int32ValueTuple) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Int32Int32ValueTuple) encodeFields(e *jx.Encoder) {
	{
		if s.Item1.Set {
			e.FieldStart("item1")
			s.Item1.Encode(e)
		}
	}
	{
		if s.Item2.Set {
			e.FieldStart("item2")
			s.Item2.Encode(e)
		}
	}
}

var jsonFieldsNameOfInt32Int32ValueTuple = [2]string{
	0: "item1",
	1: "item2",
}

// Decode decodes Int32Int32ValueTuple from json.
func (s *Int32Int32ValueTuple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Int32Int32ValueTuple to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item1":
			if err := func() error {
				s.Item1.Reset()
				if err := s.Item1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item1\"")
			}
		case "item2":
			if err := func() error {
				s.Item2.Reset()
				if err := s.Item2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item2\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Int32Int32ValueTuple")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Int32Int32ValueTuple) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Int32Int32ValueTuple) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Group as json.
func (o OptGroup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Group from json.
func (o *OptGroup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGroup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []OwnerShip as json.
func (o OptNilOwnerShipArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []OwnerShip from json.
func (o *OptNilOwnerShipArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilOwnerShipArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []OwnerShip
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]OwnerShip, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem OwnerShip
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilOwnerShipArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilOwnerShipArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []Product as json.
func (o OptNilProductArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []Product from json.
func (o *OptNilProductArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilProductArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []Product
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]Product, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem Product
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilProductArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilProductArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []PurchaseableProduct as json.
func (o OptNilPurchaseableProductArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []PurchaseableProduct from json.
func (o *OptNilPurchaseableProductArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPurchaseableProductArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []PurchaseableProduct
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]PurchaseableProduct, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem PurchaseableProduct
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPurchaseableProductArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPurchaseableProductArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []Rule as json.
func (o OptNilRuleArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []Rule from json.
func (o *OptNilRuleArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilRuleArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []Rule
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]Rule, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem Rule
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilRuleArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilRuleArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []RuleCreate as json.
func (o OptNilRuleCreateArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []RuleCreate from json.
func (o *OptNilRuleCreateArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilRuleCreateArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []RuleCreate
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]RuleCreate, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem RuleCreate
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilRuleCreateArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilRuleCreateArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SystemStateGroups as json.
func (o OptNilSystemStateGroups) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SystemStateGroups from json.
func (o *OptNilSystemStateGroups) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSystemStateGroups to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SystemStateGroups
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SystemStateGroups)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSystemStateGroups) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSystemStateGroups) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []TopUpProduct as json.
func (o OptNilTopUpProductArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []TopUpProduct from json.
func (o *OptNilTopUpProductArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilTopUpProductArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []TopUpProduct
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]TopUpProduct, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem TopUpProduct
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilTopUpProductArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilTopUpProductArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Product as json.
func (o OptProduct) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Product from json.
func (o *OptProduct) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProduct to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProduct) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProduct) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProductType as json.
func (o OptProductType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProductType from json.
func (o *OptProductType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProductType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProductType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProductType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PurchaseableProduct as json.
func (o OptPurchaseableProduct) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PurchaseableProduct from json.
func (o *OptPurchaseableProduct) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPurchaseableProduct to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPurchaseableProduct) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPurchaseableProduct) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleFlags as json.
func (o OptRuleFlags) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RuleFlags from json.
func (o *OptRuleFlags) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRuleFlags to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRuleFlags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRuleFlags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OwnerShip) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OwnerShip) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Product.Set {
			e.FieldStart("product")
			s.Product.Encode(e)
		}
	}
	{
		if s.Expires.Set {
			e.FieldStart("expires")
			s.Expires.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfOwnerShip = [3]string{
	0: "id",
	1: "product",
	2: "expires",
}

// Decode decodes OwnerShip from json.
func (s *OwnerShip) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OwnerShip to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "product":
			if err := func() error {
				s.Product.Reset()
				if err := s.Product.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product\"")
			}
		case "expires":
			if err := func() error {
				s.Expires.Reset()
				if err := s.Expires.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OwnerShip")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OwnerShip) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OwnerShip) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlanedTransaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlanedTransaction) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Product.Set {
			e.FieldStart("product")
			s.Product.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.Reference.Set {
			e.FieldStart("reference")
			s.Reference.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfPlanedTransaction = [5]string{
	0: "id",
	1: "product",
	2: "amount",
	3: "reference",
	4: "timestamp",
}

// Decode decodes PlanedTransaction from json.
func (s *PlanedTransaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlanedTransaction to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "product":
			if err := func() error {
				s.Product.Reset()
				if err := s.Product.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"product\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "reference":
			if err := func() error {
				s.Reference.Reset()
				if err := s.Reference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reference\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlanedTransaction")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlanedTransaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlanedTransaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Product) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Product) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Cost.Set {
			e.FieldStart("cost")
			s.Cost.Encode(e)
		}
	}
	{
		if s.OwnershipSeconds.Set {
			e.FieldStart("ownershipSeconds")
			s.OwnershipSeconds.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfProduct = [7]string{
	0: "id",
	1: "title",
	2: "slug",
	3: "description",
	4: "cost",
	5: "ownershipSeconds",
	6: "type",
}

// Decode decodes Product from json.
func (s *Product) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Product to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "cost":
			if err := func() error {
				s.Cost.Reset()
				if err := s.Cost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cost\"")
			}
		case "ownershipSeconds":
			if err := func() error {
				s.OwnershipSeconds.Reset()
				if err := s.OwnershipSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownershipSeconds\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Product")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Product) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Product) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProductType as json.
func (s ProductType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProductType from json.
func (s *ProductType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProductType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProductType(v) {
	case ProductTypeNONE:
		*s = ProductTypeNONE
	case ProductTypeSERVICE:
		*s = ProductTypeSERVICE
	case ProductTypeCOLLECTABLE:
		*s = ProductTypeCOLLECTABLE
	case ProductTypeTOPUP:
		*s = ProductTypeTOPUP
	case ProductTypeLOCKED:
		*s = ProductTypeLOCKED
	case ProductTypeDISABLED:
		*s = ProductTypeDISABLED
	case ProductTypeVARIABLEPRICE:
		*s = ProductTypeVARIABLEPRICE
	default:
		*s = ProductType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProductType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProductType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PurchaseableProduct) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PurchaseableProduct) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Cost.Set {
			e.FieldStart("cost")
			s.Cost.Encode(e)
		}
	}
	{
		if s.OwnershipSeconds.Set {
			e.FieldStart("ownershipSeconds")
			s.OwnershipSeconds.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfPurchaseableProduct = [7]string{
	0: "id",
	1: "title",
	2: "slug",
	3: "description",
	4: "cost",
	5: "ownershipSeconds",
	6: "type",
}

// Decode decodes PurchaseableProduct from json.
func (s *PurchaseableProduct) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PurchaseableProduct to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "cost":
			if err := func() error {
				s.Cost.Reset()
				if err := s.Cost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cost\"")
			}
		case "ownershipSeconds":
			if err := func() error {
				s.OwnershipSeconds.Reset()
				if err := s.OwnershipSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownershipSeconds\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PurchaseableProduct")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PurchaseableProduct) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PurchaseableProduct) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Rule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Rule) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.Requires.Set {
			e.FieldStart("requires")
			s.Requires.Encode(e)
		}
	}
	{
		if s.Targets.Set {
			e.FieldStart("targets")
			s.Targets.Encode(e)
		}
	}
	{
		if s.Flags.Set {
			e.FieldStart("flags")
			s.Flags.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
}

var jsonFieldsNameOfRule = [7]string{
	0: "id",
	1: "slug",
	2: "priority",
	3: "requires",
	4: "targets",
	5: "flags",
	6: "amount",
}

// Decode decodes Rule from json.
func (s *Rule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Rule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "requires":
			if err := func() error {
				s.Requires.Reset()
				if err := s.Requires.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires\"")
			}
		case "targets":
			if err := func() error {
				s.Targets.Reset()
				if err := s.Targets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targets\"")
			}
		case "flags":
			if err := func() error {
				s.Flags.Reset()
				if err := s.Flags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flags\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Rule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Rule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Rule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleCreate) encodeFields(e *jx.Encoder) {
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.RequiresGroup.Set {
			e.FieldStart("requiresGroup")
			s.RequiresGroup.Encode(e)
		}
	}
	{
		if s.TargetsGroup.Set {
			e.FieldStart("targetsGroup")
			s.TargetsGroup.Encode(e)
		}
	}
	{
		if s.Flags.Set {
			e.FieldStart("flags")
			s.Flags.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
}

var jsonFieldsNameOfRuleCreate = [6]string{
	0: "slug",
	1: "priority",
	2: "requiresGroup",
	3: "targetsGroup",
	4: "flags",
	5: "amount",
}

// Decode decodes RuleCreate from json.
func (s *RuleCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleCreate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "requiresGroup":
			if err := func() error {
				s.RequiresGroup.Reset()
				if err := s.RequiresGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiresGroup\"")
			}
		case "targetsGroup":
			if err := func() error {
				s.TargetsGroup.Reset()
				if err := s.TargetsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetsGroup\"")
			}
		case "flags":
			if err := func() error {
				s.Flags.Reset()
				if err := s.Flags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flags\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleCreate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleFlags as json.
func (s RuleFlags) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RuleFlags from json.
func (s *RuleFlags) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleFlags to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RuleFlags(v) {
	case RuleFlagsNONE:
		*s = RuleFlagsNONE
	case RuleFlagsINVERT:
		*s = RuleFlagsINVERT
	case RuleFlagsPERCENT:
		*s = RuleFlagsPERCENT
	case RuleFlagsLONGER:
		*s = RuleFlagsLONGER
	case RuleFlagsDISCOUNT:
		*s = RuleFlagsDISCOUNT
	case RuleFlagsEARLYBREAK:
		*s = RuleFlagsEARLYBREAK
	case RuleFlagsBLOCKPURCHASE:
		*s = RuleFlagsBLOCKPURCHASE
	default:
		*s = RuleFlags(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RuleFlags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleFlags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleResult) encodeFields(e *jx.Encoder) {
	{
		if s.ModifiedProduct.Set {
			e.FieldStart("modifiedProduct")
			s.ModifiedProduct.Encode(e)
		}
	}
	{
		if s.Rules.Set {
			e.FieldStart("rules")
			s.Rules.Encode(e)
		}
	}
}

var jsonFieldsNameOfRuleResult = [2]string{
	0: "modifiedProduct",
	1: "rules",
}

// Decode decodes RuleResult from json.
func (s *RuleResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "modifiedProduct":
			if err := func() error {
				s.ModifiedProduct.Reset()
				if err := s.ModifiedProduct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifiedProduct\"")
			}
		case "rules":
			if err := func() error {
				s.Rules.Reset()
				if err := s.Rules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemState) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemState) encodeFields(e *jx.Encoder) {
	{
		if s.Products.Set {
			e.FieldStart("products")
			s.Products.Encode(e)
		}
	}
	{
		if s.TopUps.Set {
			e.FieldStart("topUps")
			s.TopUps.Encode(e)
		}
	}
	{
		if s.Groups.Set {
			e.FieldStart("groups")
			s.Groups.Encode(e)
		}
	}
	{
		if s.Rules.Set {
			e.FieldStart("rules")
			s.Rules.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemState = [4]string{
	0: "products",
	1: "topUps",
	2: "groups",
	3: "rules",
}

// Decode decodes SystemState from json.
func (s *SystemState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemState to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "products":
			if err := func() error {
				s.Products.Reset()
				if err := s.Products.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"products\"")
			}
		case "topUps":
			if err := func() error {
				s.TopUps.Reset()
				if err := s.TopUps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topUps\"")
			}
		case "groups":
			if err := func() error {
				s.Groups.Reset()
				if err := s.Groups.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "rules":
			if err := func() error {
				s.Rules.Reset()
				if err := s.Rules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemState")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SystemStateGroups) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SystemStateGroups) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if elem == nil {
			e.Null()
		} else {
			e.ArrStart()
			for _, elem := range elem {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

// Decode decodes SystemStateGroups from json.
func (s *SystemStateGroups) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemStateGroups to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			switch tt := d.Next(); tt {
			case jx.Null:
				if err := d.Skip(); err != nil {
					return err
				}
			default:
				elem = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elemElem string
					v, err := d.Str()
					elemElem = string(v)
					if err != nil {
						return err
					}
					elem = append(elem, elemElem)
					return nil
				}); err != nil {
					return err
				}
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemStateGroups")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SystemStateGroups) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemStateGroups) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TopUpIdResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TopUpIdResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.DirctLink.Set {
			e.FieldStart("dirctLink")
			s.DirctLink.Encode(e)
		}
	}
}

var jsonFieldsNameOfTopUpIdResponse = [2]string{
	0: "id",
	1: "dirctLink",
}

// Decode decodes TopUpIdResponse from json.
func (s *TopUpIdResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopUpIdResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "dirctLink":
			if err := func() error {
				s.DirctLink.Reset()
				if err := s.DirctLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dirctLink\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopUpIdResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TopUpIdResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TopUpIdResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TopUpOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TopUpOptions) encodeFields(e *jx.Encoder) {
	{
		if s.SuccessUrl.Set {
			e.FieldStart("successUrl")
			s.SuccessUrl.Encode(e)
		}
	}
	{
		if s.CancelUrl.Set {
			e.FieldStart("cancelUrl")
			s.CancelUrl.Encode(e)
		}
	}
	{
		if s.UserEmail.Set {
			e.FieldStart("userEmail")
			s.UserEmail.Encode(e)
		}
	}
	{
		if s.TopUpAmount.Set {
			e.FieldStart("topUpAmount")
			s.TopUpAmount.Encode(e)
		}
	}
}

var jsonFieldsNameOfTopUpOptions = [4]string{
	0: "successUrl",
	1: "cancelUrl",
	2: "userEmail",
	3: "topUpAmount",
}

// Decode decodes TopUpOptions from json.
func (s *TopUpOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopUpOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "successUrl":
			if err := func() error {
				s.SuccessUrl.Reset()
				if err := s.SuccessUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successUrl\"")
			}
		case "cancelUrl":
			if err := func() error {
				s.CancelUrl.Reset()
				if err := s.CancelUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancelUrl\"")
			}
		case "userEmail":
			if err := func() error {
				s.UserEmail.Reset()
				if err := s.UserEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userEmail\"")
			}
		case "topUpAmount":
			if err := func() error {
				s.TopUpAmount.Reset()
				if err := s.TopUpAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topUpAmount\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopUpOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TopUpOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TopUpOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TopUpProduct) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TopUpProduct) encodeFields(e *jx.Encoder) {
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currencyCode")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.ProviderSlug.Set {
			e.FieldStart("providerSlug")
			s.ProviderSlug.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Cost.Set {
			e.FieldStart("cost")
			s.Cost.Encode(e)
		}
	}
	{
		if s.OwnershipSeconds.Set {
			e.FieldStart("ownershipSeconds")
			s.OwnershipSeconds.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfTopUpProduct = [10]string{
	0: "price",
	1: "currencyCode",
	2: "providerSlug",
	3: "id",
	4: "title",
	5: "slug",
	6: "description",
	7: "cost",
	8: "ownershipSeconds",
	9: "type",
}

// Decode decodes TopUpProduct from json.
func (s *TopUpProduct) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TopUpProduct to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "currencyCode":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currencyCode\"")
			}
		case "providerSlug":
			if err := func() error {
				s.ProviderSlug.Reset()
				if err := s.ProviderSlug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerSlug\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "cost":
			if err := func() error {
				s.Cost.Reset()
				if err := s.Cost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cost\"")
			}
		case "ownershipSeconds":
			if err := func() error {
				s.OwnershipSeconds.Reset()
				if err := s.OwnershipSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownershipSeconds\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TopUpProduct")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TopUpProduct) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TopUpProduct) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionEvent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionEvent) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.UserId.Set {
			e.FieldStart("userId")
			s.UserId.Encode(e)
		}
	}
	{
		if s.ProductSlug.Set {
			e.FieldStart("productSlug")
			s.ProductSlug.Encode(e)
		}
	}
	{
		if s.ProductId.Set {
			e.FieldStart("productId")
			s.ProductId.Encode(e)
		}
	}
	{
		if s.OwnedSeconds.Set {
			e.FieldStart("ownedSeconds")
			s.OwnedSeconds.Encode(e)
		}
	}
	{
		if s.ProductType.Set {
			e.FieldStart("productType")
			s.ProductType.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.Reference.Set {
			e.FieldStart("reference")
			s.Reference.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfTransactionEvent = [9]string{
	0: "id",
	1: "userId",
	2: "productSlug",
	3: "productId",
	4: "ownedSeconds",
	5: "productType",
	6: "amount",
	7: "reference",
	8: "timestamp",
}

// Decode decodes TransactionEvent from json.
func (s *TransactionEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionEvent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "userId":
			if err := func() error {
				s.UserId.Reset()
				if err := s.UserId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		case "productSlug":
			if err := func() error {
				s.ProductSlug.Reset()
				if err := s.ProductSlug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productSlug\"")
			}
		case "productId":
			if err := func() error {
				s.ProductId.Reset()
				if err := s.ProductId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productId\"")
			}
		case "ownedSeconds":
			if err := func() error {
				s.OwnedSeconds.Reset()
				if err := s.OwnedSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownedSeconds\"")
			}
		case "productType":
			if err := func() error {
				s.ProductType.Reset()
				if err := s.ProductType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"productType\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "reference":
			if err := func() error {
				s.Reference.Reset()
				if err := s.Reference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reference\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionEvent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransferRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransferRequest) encodeFields(e *jx.Encoder) {
	{
		if s.TargetUser.Set {
			e.FieldStart("targetUser")
			s.TargetUser.Encode(e)
		}
	}
	{
		if s.Reference.Set {
			e.FieldStart("reference")
			s.Reference.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
}

var jsonFieldsNameOfTransferRequest = [3]string{
	0: "targetUser",
	1: "reference",
	2: "amount",
}

// Decode decodes TransferRequest from json.
func (s *TransferRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "targetUser":
			if err := func() error {
				s.TargetUser.Reset()
				if err := s.TargetUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetUser\"")
			}
		case "reference":
			if err := func() error {
				s.Reference.Reset()
				if err := s.Reference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reference\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransferRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransferRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *User) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *User) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ExternalId.Set {
			e.FieldStart("externalId")
			s.ExternalId.Encode(e)
		}
	}
	{
		if s.Balance.Set {
			e.FieldStart("balance")
			s.Balance.Encode(e)
		}
	}
	{
		if s.AvailableBalance.Set {
			e.FieldStart("availableBalance")
			s.AvailableBalance.Encode(e)
		}
	}
	{
		if s.Owns.Set {
			e.FieldStart("owns")
			s.Owns.Encode(e)
		}
	}
}

var jsonFieldsNameOfUser = [5]string{
	0: "id",
	1: "externalId",
	2: "balance",
	3: "availableBalance",
	4: "owns",
}

// Decode decodes User from json.
func (s *User) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode User to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "externalId":
			if err := func() error {
				s.ExternalId.Reset()
				if err := s.ExternalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalId\"")
			}
		case "balance":
			if err := func() error {
				s.Balance.Reset()
				if err := s.Balance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		case "availableBalance":
			if err := func() error {
				s.AvailableBalance.Reset()
				if err := s.AvailableBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableBalance\"")
			}
		case "owns":
			if err := func() error {
				s.Owns.Reset()
				if err := s.Owns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owns\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode User")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *User) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *User) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UserUserIdOwnsUntilPostOKApplicationJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UserUserIdOwnsUntilPostOKApplicationJSON) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		json.EncodeDateTime(e, elem)
	}
}

// Decode decodes UserUserIdOwnsUntilPostOKApplicationJSON from json.
func (s *UserUserIdOwnsUntilPostOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUserIdOwnsUntilPostOKApplicationJSON to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem time.Time
		if err := func() error {
			v, err := json.DecodeDateTime(d)
			elem = v
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserUserIdOwnsUntilPostOKApplicationJSON")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserUserIdOwnsUntilPostOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUserIdOwnsUntilPostOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
