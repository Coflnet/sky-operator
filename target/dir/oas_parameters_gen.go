// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// GroupGetParams is parameters of GET /Group operation.
type GroupGetParams struct {
	Offset OptInt32
	Amount OptInt32
}

func unpackGroupGetParams(packed middleware.Parameters) (params GroupGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "amount",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Amount = v.(OptInt32)
		}
	}
	return params
}

func decodeGroupGetParams(args [0]string, r *http.Request) (params GroupGetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: offset.
	{
		val := int32(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: amount.
	{
		val := int32(20)
		params.Amount.SetTo(val)
	}
	// Decode query: amount.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "amount",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAmountVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotAmountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Amount.SetTo(paramsDotAmountVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "amount",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GroupGroupSlugDeleteParams is parameters of DELETE /Group/{groupSlug} operation.
type GroupGroupSlugDeleteParams struct {
	GroupSlug string
}

func unpackGroupGroupSlugDeleteParams(packed middleware.Parameters) (params GroupGroupSlugDeleteParams) {
	{
		key := middleware.ParameterKey{
			Name: "groupSlug",
			In:   "path",
		}
		params.GroupSlug = packed[key].(string)
	}
	return params
}

func decodeGroupGroupSlugDeleteParams(args [1]string, r *http.Request) (params GroupGroupSlugDeleteParams, _ error) {
	// Decode path: groupSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "groupSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GroupSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "groupSlug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GroupGroupSlugGetParams is parameters of GET /Group/{groupSlug} operation.
type GroupGroupSlugGetParams struct {
	GroupSlug string
}

func unpackGroupGroupSlugGetParams(packed middleware.Parameters) (params GroupGroupSlugGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "groupSlug",
			In:   "path",
		}
		params.GroupSlug = packed[key].(string)
	}
	return params
}

func decodeGroupGroupSlugGetParams(args [1]string, r *http.Request) (params GroupGroupSlugGetParams, _ error) {
	// Decode path: groupSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "groupSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GroupSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "groupSlug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GroupGroupSlugProductsDeleteParams is parameters of DELETE /Group/{groupSlug}/products operation.
type GroupGroupSlugProductsDeleteParams struct {
	GroupSlug string
}

func unpackGroupGroupSlugProductsDeleteParams(packed middleware.Parameters) (params GroupGroupSlugProductsDeleteParams) {
	{
		key := middleware.ParameterKey{
			Name: "groupSlug",
			In:   "path",
		}
		params.GroupSlug = packed[key].(string)
	}
	return params
}

func decodeGroupGroupSlugProductsDeleteParams(args [1]string, r *http.Request) (params GroupGroupSlugProductsDeleteParams, _ error) {
	// Decode path: groupSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "groupSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GroupSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "groupSlug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GroupGroupSlugProductsPostParams is parameters of POST /Group/{groupSlug}/products operation.
type GroupGroupSlugProductsPostParams struct {
	GroupSlug string
}

func unpackGroupGroupSlugProductsPostParams(packed middleware.Parameters) (params GroupGroupSlugProductsPostParams) {
	{
		key := middleware.ParameterKey{
			Name: "groupSlug",
			In:   "path",
		}
		params.GroupSlug = packed[key].(string)
	}
	return params
}

func decodeGroupGroupSlugProductsPostParams(args [1]string, r *http.Request) (params GroupGroupSlugProductsPostParams, _ error) {
	// Decode path: groupSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "groupSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GroupSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "groupSlug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GroupGroupSlugPutParams is parameters of PUT /Group/{groupSlug} operation.
type GroupGroupSlugPutParams struct {
	GroupSlug string
}

func unpackGroupGroupSlugPutParams(packed middleware.Parameters) (params GroupGroupSlugPutParams) {
	{
		key := middleware.ParameterKey{
			Name: "groupSlug",
			In:   "path",
		}
		params.GroupSlug = packed[key].(string)
	}
	return params
}

func decodeGroupGroupSlugPutParams(args [1]string, r *http.Request) (params GroupGroupSlugPutParams, _ error) {
	// Decode path: groupSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "groupSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GroupSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "groupSlug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ProductsGetParams is parameters of GET /Products operation.
type ProductsGetParams struct {
	Offset OptInt32
	Amount OptInt32
}

func unpackProductsGetParams(packed middleware.Parameters) (params ProductsGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "amount",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Amount = v.(OptInt32)
		}
	}
	return params
}

func decodeProductsGetParams(args [0]string, r *http.Request) (params ProductsGetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: offset.
	{
		val := int32(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: amount.
	{
		val := int32(20)
		params.Amount.SetTo(val)
	}
	// Decode query: amount.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "amount",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAmountVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotAmountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Amount.SetTo(paramsDotAmountVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "amount",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ProductsPProductSlugGetParams is parameters of GET /Products/p/{productSlug} operation.
type ProductsPProductSlugGetParams struct {
	ProductSlug string
}

func unpackProductsPProductSlugGetParams(packed middleware.Parameters) (params ProductsPProductSlugGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "productSlug",
			In:   "path",
		}
		params.ProductSlug = packed[key].(string)
	}
	return params
}

func decodeProductsPProductSlugGetParams(args [1]string, r *http.Request) (params ProductsPProductSlugGetParams, _ error) {
	// Decode path: productSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "productSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProductSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "productSlug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ProductsServiceServiceSlugCountGetParams is parameters of GET /Products/service/{serviceSlug}/count operation.
type ProductsServiceServiceSlugCountGetParams struct {
	ServiceSlug string
}

func unpackProductsServiceServiceSlugCountGetParams(packed middleware.Parameters) (params ProductsServiceServiceSlugCountGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "serviceSlug",
			In:   "path",
		}
		params.ServiceSlug = packed[key].(string)
	}
	return params
}

func decodeProductsServiceServiceSlugCountGetParams(args [1]string, r *http.Request) (params ProductsServiceServiceSlugCountGetParams, _ error) {
	// Decode path: serviceSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "serviceSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ServiceSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "serviceSlug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ProductsServiceServiceSlugIdsGetParams is parameters of GET /Products/service/{serviceSlug}/ids operation.
type ProductsServiceServiceSlugIdsGetParams struct {
	ServiceSlug string
}

func unpackProductsServiceServiceSlugIdsGetParams(packed middleware.Parameters) (params ProductsServiceServiceSlugIdsGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "serviceSlug",
			In:   "path",
		}
		params.ServiceSlug = packed[key].(string)
	}
	return params
}

func decodeProductsServiceServiceSlugIdsGetParams(args [1]string, r *http.Request) (params ProductsServiceServiceSlugIdsGetParams, _ error) {
	// Decode path: serviceSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "serviceSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ServiceSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "serviceSlug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ProductsServicesGetParams is parameters of GET /Products/services operation.
type ProductsServicesGetParams struct {
	Offset OptInt32
	Amount OptInt32
}

func unpackProductsServicesGetParams(packed middleware.Parameters) (params ProductsServicesGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "amount",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Amount = v.(OptInt32)
		}
	}
	return params
}

func decodeProductsServicesGetParams(args [0]string, r *http.Request) (params ProductsServicesGetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: offset.
	{
		val := int32(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: amount.
	{
		val := int32(20)
		params.Amount.SetTo(val)
	}
	// Decode query: amount.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "amount",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAmountVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotAmountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Amount.SetTo(paramsDotAmountVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "amount",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ProductsTopupGetParams is parameters of GET /Products/topup operation.
type ProductsTopupGetParams struct {
	Offset OptInt32
	Amount OptInt32
}

func unpackProductsTopupGetParams(packed middleware.Parameters) (params ProductsTopupGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "amount",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Amount = v.(OptInt32)
		}
	}
	return params
}

func decodeProductsTopupGetParams(args [0]string, r *http.Request) (params ProductsTopupGetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: offset.
	{
		val := int32(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: amount.
	{
		val := int32(20)
		params.Amount.SetTo(val)
	}
	// Decode query: amount.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "amount",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAmountVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotAmountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Amount.SetTo(paramsDotAmountVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "amount",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ProductsUserUserIdGetParams is parameters of GET /Products/user/{userId} operation.
type ProductsUserUserIdGetParams struct {
	UserId       string
	ProductSlugs []string
}

func unpackProductsUserUserIdGetParams(packed middleware.Parameters) (params ProductsUserUserIdGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "productSlugs",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ProductSlugs = v.([]string)
		}
	}
	return params
}

func decodeProductsUserUserIdGetParams(args [1]string, r *http.Request) (params ProductsUserUserIdGetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: productSlugs.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "productSlugs",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotProductSlugsVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotProductSlugsVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.ProductSlugs = append(params.ProductSlugs, paramsDotProductSlugsVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "productSlugs",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// RulesGetParams is parameters of GET /Rules operation.
type RulesGetParams struct {
	Offset OptInt32
	Amount OptInt32
}

func unpackRulesGetParams(packed middleware.Parameters) (params RulesGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "offset",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Offset = v.(OptInt32)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "amount",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Amount = v.(OptInt32)
		}
	}
	return params
}

func decodeRulesGetParams(args [0]string, r *http.Request) (params RulesGetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: offset.
	{
		val := int32(0)
		params.Offset.SetTo(val)
	}
	// Decode query: offset.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "offset",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: amount.
	{
		val := int32(20)
		params.Amount.SetTo(val)
	}
	// Decode query: amount.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "amount",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAmountVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotAmountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Amount.SetTo(paramsDotAmountVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "amount",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// RulesRuleSlugDeleteParams is parameters of DELETE /Rules/{ruleSlug} operation.
type RulesRuleSlugDeleteParams struct {
	RuleSlug string
}

func unpackRulesRuleSlugDeleteParams(packed middleware.Parameters) (params RulesRuleSlugDeleteParams) {
	{
		key := middleware.ParameterKey{
			Name: "ruleSlug",
			In:   "path",
		}
		params.RuleSlug = packed[key].(string)
	}
	return params
}

func decodeRulesRuleSlugDeleteParams(args [1]string, r *http.Request) (params RulesRuleSlugDeleteParams, _ error) {
	// Decode path: ruleSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ruleSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RuleSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ruleSlug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// RulesRuleSlugGetParams is parameters of GET /Rules/{ruleSlug} operation.
type RulesRuleSlugGetParams struct {
	RuleSlug string
}

func unpackRulesRuleSlugGetParams(packed middleware.Parameters) (params RulesRuleSlugGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "ruleSlug",
			In:   "path",
		}
		params.RuleSlug = packed[key].(string)
	}
	return params
}

func decodeRulesRuleSlugGetParams(args [1]string, r *http.Request) (params RulesRuleSlugGetParams, _ error) {
	// Decode path: ruleSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ruleSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RuleSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "ruleSlug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// TopUpCustomPostParams is parameters of POST /TopUp/custom operation.
type TopUpCustomPostParams struct {
	UserId OptString
}

func unpackTopUpCustomPostParams(packed middleware.Parameters) (params TopUpCustomPostParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.UserId = v.(OptString)
		}
	}
	return params
}

func decodeTopUpCustomPostParams(args [0]string, r *http.Request) (params TopUpCustomPostParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: userId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "userId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUserIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotUserIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.UserId.SetTo(paramsDotUserIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// TopUpPaypalPostParams is parameters of POST /TopUp/paypal operation.
type TopUpPaypalPostParams struct {
	UserId    OptString
	ProductId OptString
}

func unpackTopUpPaypalPostParams(packed middleware.Parameters) (params TopUpPaypalPostParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.UserId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "productId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ProductId = v.(OptString)
		}
	}
	return params
}

func decodeTopUpPaypalPostParams(args [0]string, r *http.Request) (params TopUpPaypalPostParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: userId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "userId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUserIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotUserIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.UserId.SetTo(paramsDotUserIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: productId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "productId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProductIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProductIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ProductId.SetTo(paramsDotProductIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "productId",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// TopUpStripePostParams is parameters of POST /TopUp/stripe operation.
type TopUpStripePostParams struct {
	UserId    OptString
	ProductId OptString
}

func unpackTopUpStripePostParams(packed middleware.Parameters) (params TopUpStripePostParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.UserId = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "productId",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.ProductId = v.(OptString)
		}
	}
	return params
}

func decodeTopUpStripePostParams(args [0]string, r *http.Request) (params TopUpStripePostParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: userId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "userId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUserIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotUserIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.UserId.SetTo(paramsDotUserIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: productId.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "productId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProductIdVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProductIdVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ProductId.SetTo(paramsDotProductIdVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "productId",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// TransactionPlanedUUserIdGetParams is parameters of GET /Transaction/planed/u/{userId} operation.
type TransactionPlanedUUserIdGetParams struct {
	UserId string
}

func unpackTransactionPlanedUUserIdGetParams(packed middleware.Parameters) (params TransactionPlanedUUserIdGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	return params
}

func decodeTransactionPlanedUUserIdGetParams(args [1]string, r *http.Request) (params TransactionPlanedUUserIdGetParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// TransactionPlanedUUserIdPostParams is parameters of POST /Transaction/planed/u/{userId} operation.
type TransactionPlanedUUserIdPostParams struct {
	UserId string
}

func unpackTransactionPlanedUUserIdPostParams(packed middleware.Parameters) (params TransactionPlanedUUserIdPostParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	return params
}

func decodeTransactionPlanedUUserIdPostParams(args [1]string, r *http.Request) (params TransactionPlanedUUserIdPostParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// TransactionPlanedUUserIdTTransactionIdDeleteParams is parameters of DELETE /Transaction/planed/u/{userId}/t/{transactionId} operation.
type TransactionPlanedUUserIdTTransactionIdDeleteParams struct {
	UserId        string
	TransactionId int32
}

func unpackTransactionPlanedUUserIdTTransactionIdDeleteParams(packed middleware.Parameters) (params TransactionPlanedUUserIdTTransactionIdDeleteParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "transactionId",
			In:   "path",
		}
		params.TransactionId = packed[key].(int32)
	}
	return params
}

func decodeTransactionPlanedUUserIdTTransactionIdDeleteParams(args [2]string, r *http.Request) (params TransactionPlanedUUserIdTTransactionIdDeleteParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: transactionId.
	if err := func() error {
		param, err := url.PathUnescape(args[1])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "transactionId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.TransactionId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "transactionId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// TransactionPlanedUUserIdTTransactionIdPutParams is parameters of PUT /Transaction/planed/u/{userId}/t/{transactionId} operation.
type TransactionPlanedUUserIdTTransactionIdPutParams struct {
	UserId        string
	TransactionId int32
}

func unpackTransactionPlanedUUserIdTTransactionIdPutParams(packed middleware.Parameters) (params TransactionPlanedUUserIdTTransactionIdPutParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "transactionId",
			In:   "path",
		}
		params.TransactionId = packed[key].(int32)
	}
	return params
}

func decodeTransactionPlanedUUserIdTTransactionIdPutParams(args [2]string, r *http.Request) (params TransactionPlanedUUserIdTTransactionIdPutParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: transactionId.
	if err := func() error {
		param, err := url.PathUnescape(args[1])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "transactionId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.TransactionId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "transactionId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// TransactionUUserIdGetParams is parameters of GET /Transaction/u/{userId} operation.
type TransactionUUserIdGetParams struct {
	UserId string
}

func unpackTransactionUUserIdGetParams(packed middleware.Parameters) (params TransactionUUserIdGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	return params
}

func decodeTransactionUUserIdGetParams(args [1]string, r *http.Request) (params TransactionUUserIdGetParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UserUserIdGetParams is parameters of GET /User/{userId} operation.
type UserUserIdGetParams struct {
	UserId string
}

func unpackUserUserIdGetParams(packed middleware.Parameters) (params UserUserIdGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	return params
}

func decodeUserUserIdGetParams(args [1]string, r *http.Request) (params UserUserIdGetParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UserUserIdOwnsLongestPostParams is parameters of POST /User/{userId}/owns/longest operation.
type UserUserIdOwnsLongestPostParams struct {
	UserId string
}

func unpackUserUserIdOwnsLongestPostParams(packed middleware.Parameters) (params UserUserIdOwnsLongestPostParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	return params
}

func decodeUserUserIdOwnsLongestPostParams(args [1]string, r *http.Request) (params UserUserIdOwnsLongestPostParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UserUserIdOwnsPostParams is parameters of POST /User/{userId}/owns operation.
type UserUserIdOwnsPostParams struct {
	UserId string
}

func unpackUserUserIdOwnsPostParams(packed middleware.Parameters) (params UserUserIdOwnsPostParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	return params
}

func decodeUserUserIdOwnsPostParams(args [1]string, r *http.Request) (params UserUserIdOwnsPostParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UserUserIdOwnsProductSlugUntilGetParams is parameters of GET /User/{userId}/owns/{productSlug}/until operation.
type UserUserIdOwnsProductSlugUntilGetParams struct {
	UserId      string
	ProductSlug string
}

func unpackUserUserIdOwnsProductSlugUntilGetParams(packed middleware.Parameters) (params UserUserIdOwnsProductSlugUntilGetParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "productSlug",
			In:   "path",
		}
		params.ProductSlug = packed[key].(string)
	}
	return params
}

func decodeUserUserIdOwnsProductSlugUntilGetParams(args [2]string, r *http.Request) (params UserUserIdOwnsProductSlugUntilGetParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: productSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[1])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "productSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProductSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "productSlug",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UserUserIdOwnsUntilPostParams is parameters of POST /User/{userId}/owns/until operation.
type UserUserIdOwnsUntilPostParams struct {
	UserId string
}

func unpackUserUserIdOwnsUntilPostParams(packed middleware.Parameters) (params UserUserIdOwnsUntilPostParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	return params
}

func decodeUserUserIdOwnsUntilPostParams(args [1]string, r *http.Request) (params UserUserIdOwnsUntilPostParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UserUserIdPostParams is parameters of POST /User/{userId} operation.
type UserUserIdPostParams struct {
	UserId string
}

func unpackUserUserIdPostParams(packed middleware.Parameters) (params UserUserIdPostParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	return params
}

func decodeUserUserIdPostParams(args [1]string, r *http.Request) (params UserUserIdPostParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UserUserIdPurchaseProductSlugPostParams is parameters of POST /User/{userId}/purchase/{productSlug} operation.
type UserUserIdPurchaseProductSlugPostParams struct {
	UserId      string
	ProductSlug string
	Price       OptInt32
}

func unpackUserUserIdPurchaseProductSlugPostParams(packed middleware.Parameters) (params UserUserIdPurchaseProductSlugPostParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "productSlug",
			In:   "path",
		}
		params.ProductSlug = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "price",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Price = v.(OptInt32)
		}
	}
	return params
}

func decodeUserUserIdPurchaseProductSlugPostParams(args [2]string, r *http.Request) (params UserUserIdPurchaseProductSlugPostParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: productSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[1])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "productSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProductSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "productSlug",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: price.
	{
		val := int32(0)
		params.Price.SetTo(val)
	}
	// Decode query: price.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "price",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPriceVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotPriceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Price.SetTo(paramsDotPriceVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "price",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// UserUserIdServicePurchaseProductSlugPostParams is parameters of POST /User/{userId}/service/purchase/{productSlug} operation.
type UserUserIdServicePurchaseProductSlugPostParams struct {
	UserId      string
	ProductSlug string
	Reference   OptString
	Count       OptInt32
}

func unpackUserUserIdServicePurchaseProductSlugPostParams(packed middleware.Parameters) (params UserUserIdServicePurchaseProductSlugPostParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "productSlug",
			In:   "path",
		}
		params.ProductSlug = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "reference",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Reference = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "count",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Count = v.(OptInt32)
		}
	}
	return params
}

func decodeUserUserIdServicePurchaseProductSlugPostParams(args [2]string, r *http.Request) (params UserUserIdServicePurchaseProductSlugPostParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: productSlug.
	if err := func() error {
		param, err := url.PathUnescape(args[1])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "productSlug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ProductSlug = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "productSlug",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: reference.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "reference",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotReferenceVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotReferenceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Reference.SetTo(paramsDotReferenceVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "reference",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: count.
	{
		val := int32(1)
		params.Count.SetTo(val)
	}
	// Decode query: count.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCountVal int32
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt32(val)
					if err != nil {
						return err
					}

					paramsDotCountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Count.SetTo(paramsDotCountVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "count",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// UserUserIdTransactionIdDeleteParams is parameters of DELETE /User/{userId}/{transactionId} operation.
type UserUserIdTransactionIdDeleteParams struct {
	UserId        string
	TransactionId int32
}

func unpackUserUserIdTransactionIdDeleteParams(packed middleware.Parameters) (params UserUserIdTransactionIdDeleteParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "transactionId",
			In:   "path",
		}
		params.TransactionId = packed[key].(int32)
	}
	return params
}

func decodeUserUserIdTransactionIdDeleteParams(args [2]string, r *http.Request) (params UserUserIdTransactionIdDeleteParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: transactionId.
	if err := func() error {
		param, err := url.PathUnescape(args[1])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "transactionId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt32(val)
				if err != nil {
					return err
				}

				params.TransactionId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "transactionId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UserUserIdTransferPostParams is parameters of POST /User/{userId}/transfer operation.
type UserUserIdTransferPostParams struct {
	UserId string
}

func unpackUserUserIdTransferPostParams(packed middleware.Parameters) (params UserUserIdTransferPostParams) {
	{
		key := middleware.ParameterKey{
			Name: "userId",
			In:   "path",
		}
		params.UserId = packed[key].(string)
	}
	return params
}

func decodeUserUserIdTransferPostParams(args [1]string, r *http.Request) (params UserUserIdTransferPostParams, _ error) {
	// Decode path: userId.
	if err := func() error {
		param, err := url.PathUnescape(args[0])
		if err != nil {
			return errors.Wrap(err, "unescape path")
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "userId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.UserId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "userId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}
